---
layout: post
title: submodule vs subtree
date: 2016-08-18 09:00:00 +0800
keywords: "git submodule subtree"
categories: "git"
---
# 背景

部门某个产品切换git一个版本以后，最近需要把工程一部分代码剥离出去，控制全量代码的读写权限。

第一个想法是采用之前做的基于Gradle的包管理，但剥离出来的部分没有明确的发布件，需要配合全量代码进行构建。

另外我们也尽量不想引入新的工具，增加团队的学习和管理成本。所以git本身提供的submodule和subtree特性就成为了选择的重点。

# 特点分析

这两者的使用和选择已经有很多经验分享，大部分认为subtree的使用更为便捷，这里就遇到的产品实际出发分析一下两者的特点

## 对工程的侵入性
subtree方案的一个使用特点就是对父工程的一般使用者完全透明，子工程目录/文件在父工程是真实存在的，一切操作照常。只有子工程的维护者需要进行特定操作。

submodule方案就明显重型很多，会产生.gitmodule文件，子工程目录实际是一个引用，要操作子工程需要使用特定的命令

两者的差异实际上是使用模型的不同，subtree的子工程类似于真实子工程的一个本地分支，可以进行本地修改，也可以推送到远端；而submodule两个工程有严格的分界，子工程的修改只会发生在子工程的分支上。

对于产品的使用场景，明确代码应该在哪个工程内修改对管理来说更有优势，使用.gitmodule明确子工程的设置也有利于整个团队认识的对齐，另外不使用submodule的吃瓜群众完全不用顾虑别分解出去的模块。

相比起来，直接使用subtree的方式更加私有化，子模块设置依赖于开发人员的认识，而非工程本身，如果整个团队只有少数人需要控制/掌握时问题不大，但如果每个特新分支的开发人员都需要使用时，那知识的传递就有些繁琐了。

## 父子工程分支的关系
subtree方案父工程分支维护时是和子工程分支绑定的，但这种绑定关系不体现在git工程中，所以也可以认为其实全无绑定，两边只是不同的分支

submodule方案父工程中的子工程目录指向的是节点引用，也没有分支的概念

另外由于父子关系的单向性，两边都会遇到另一个问题，当子工程需要验证时，它如何选择父工程分支呢。

## 分支间Merge
subtree方案可以很轻松得进行分支间的merge，但如果没有将分支的修改推送到子工程分支，会导致两侧的修改失去同步关系，另外如果两侧的分支模型不一致明显也会产生问题。
还有一点要指出的是subtree的merge无法识别fast-forward场景，始终要解决冲突，生成一个merge节点
另外这种Merge模式在我们的使用场景会有一个问题，Merge发生在权限控制的父工程中，但如何Merge的知识存在于子工程的开发人员中

submodule方案，分支间merge会形成分支节点号的冲突，需要在子工程先完成合并，再在主工程进行修改，否则很难处理
